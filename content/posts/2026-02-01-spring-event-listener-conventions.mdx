---
title: "Spring Event Listener 컨벤션 가이드"
description: "이벤트 네이밍, 리스너 클래스 분리 기준, 핸들러 메소드 네이밍을 정리했다. Chris Richardson, Vaughn Vernon, Martin Fowler 등 업계 권위자들의 의견과 Axon Framework 공식 문서를 참고했다."
date: "2026-02-01"
published: true
tags: ["java", "spring", "event-driven", "ddd", "conventions"]
---

## 들어가며

프로젝트에서 이벤트 리스너 패턴이 여러 개 혼재되어 있었다.

```java
// 패턴 1: 액션 기반 클래스명 + 비즈니스 동사 메소드
public class CreateOrderListener {
    public void createOrder(ReceivedOrder event) { }
}

// 패턴 2: 이벤트 기반 클래스명 + 동작 설명 메소드
public class OrderAssignedListener {
    public void saveTracking(OrderAssigned event) { }
    public void sendNotification(OrderAssigned event) { }
}

// 패턴 3: 목적 기반 클래스명 + 간결한 메소드
public class AppPushEventListener {
    public void appPush(AppPushEvent event) { }
}
```

팀에서 어떤 패턴을 따라야 하는지 논의가 필요했다.
구루들의 의견과 프레임워크 공식 가이드를 조사해봤다.

결론부터 말하자면, **상황에 따라 다른 패턴을 쓰는 게 맞다**.
무조건 하나의 패턴을 강제하는 건 오히려 해가 된다.

> **시리즈 안내**
> - Part 1: 이벤트 네이밍과 리스너 컨벤션 (현재 글)
> - [Part 2: Spring @EventListener 함정과 해결책](/posts/spring-event-listener-pitfalls)
> - [Part 3: DDD 이벤트 설계 안티패턴](/posts/ddd-event-anti-patterns)


## 구루들의 의견

### Chris Richardson (Microservices Patterns 저자)

> "Organize the business logic of a service as a collection of DDD aggregates that emit domain events when they are created or updated."
>
> — [Domain Event Pattern](https://microservices.io/patterns/data/domain-event.html)

핵심 주장:
- 도메인 이벤트는 **Aggregate의 상태 변경**을 알리는 메커니즘
- Saga, CQRS 패턴에서 서비스 간 협력의 핵심
- 이벤트는 **비동기 메시징**의 한 종류일 뿐, 전부가 아님

FTGO 애플리케이션(책의 예제 코드)에서 이벤트 네이밍 패턴:

```java
// 과거 시제 + 도메인 관점
public class OrderCreatedEvent implements OrderDomainEvent { }
public class OrderAuthorized implements OrderDomainEvent { }
public class OrderCancelled implements OrderDomainEvent { }
public class OrderRejected implements OrderDomainEvent { }
public class TicketAcceptedEvent implements TicketDomainEvent { }
public class DeliveryPickedUp implements DomainEvent { }
```

— [FTGO Application](https://github.com/microservices-patterns/ftgo-application)

주목할 점: **Event suffix 사용이 일관되지 않다**. `OrderCreatedEvent`와 `OrderAuthorized`가 공존한다. 이는 suffix보다 **과거 시제**가 더 중요함을 보여준다.

### Vaughn Vernon (IDDD 저자)

> "Domain Events capture the memory of something interesting which affects the domain."
>
> — Implementing Domain-Driven Design, Chapter 8

핵심 주장:
- 도메인 이벤트는 **비즈니스 관점**에서 네이밍
- `OrderWasPlaced` 보다 `OrderPlaced`가 선호됨 (간결함)
- 이벤트 클래스는 **불변(Immutable)**이어야 함

### Martin Fowler (리팩토링, P of EAA 저자)

> "The essence of a Domain Event is that you use it to capture things that can trigger a change to the state of the application you are developing."
>
> — [Domain Event](https://martinfowler.com/eaaDev/DomainEvent.html)

핵심 주장:
- 이벤트 데이터는 두 종류로 구분: **불변 소스 데이터** + **가변 처리 데이터**
- 시간 정보는 **발생 시점(occurred)**과 **인지 시점(noticed)** 모두 고려
- 이벤트는 시스템 입력의 **감사 로그(Audit Log)** 역할

### Mathias Verraes (DDD Europe 공동창립자)

> "Name events in terms of the business, not in terms of technical implementation."
>
> — [Designing Events First](https://verraes.net/2019/06/messaging-patterns-natural-language/)

핵심 주장:
- ❌ `UserTableRowInserted` (기술 관점)
- ✅ `CustomerRegistered` (비즈니스 관점)


## 이벤트 네이밍 컨벤션

업계에서 합의된 내용을 정리하면 다음과 같다.

| 항목 | 권장 | 비권장 | 이유 |
|------|------|--------|------|
| **시제** | 과거 시제 | 현재/미래 시제 | 이벤트는 이미 발생한 사실 |
| **관점** | 비즈니스 관점 | 기술 관점 | 도메인 언어 사용 |
| **Event suffix** | 선택적 | - | 일관성이 더 중요 |

```java
// ✅ 권장
public class OrderCreated { }
public class PaymentCompleted { }
public class DeliveryAssigned { }

// ⚠️ 허용 (일관성 있게 사용 시)
public class OrderCreatedEvent { }
public class PaymentCompletedEvent { }

// ❌ 비권장
public class CreateOrder { }           // 명령(Command)처럼 보임
public class OrderCreation { }         // 명사형 - 이벤트인지 불분명
public class OrderTableInserted { }    // 기술 관점
```

Event suffix를 쓸지 말지는 팀 합의 하에 일관되게 사용하면 된다.
개인적으로는 과거 시제만으로 충분히 이벤트임을 알 수 있어서 suffix 없이 사용하는 걸 선호한다.


## 리스너 클래스 분리 기준

여기서부터가 핵심이다.
Axon Framework 공식 가이드를 기반으로 정리했다.

> "Group event handlers by their purpose, not by the events they handle."
>
> — [Axon Framework Event Handling](https://docs.axoniq.io/reference-guide/axon-framework/events/event-handlers)

### ❌ 이벤트 타입별 분리 (권장하지 않음)

```java
// 각 이벤트마다 별도 리스너 → 파편화
public class OrderCreatedListener { }
public class OrderShippedListener { }
public class OrderDeliveredListener { }
public class OrderCanceledListener { }
```

**문제점:**
- 클래스 수 폭증
- 관련 로직이 여러 파일에 분산
- 전체 흐름 파악 어려움

### ✅ Read Model (Projection)별 분리

```java
// 하나의 read model을 업데이트하는 모든 이벤트를 한 곳에서 처리
@Component
public class OrderSummaryProjection {
    
    @EventHandler
    public void on(OrderCreated event) { /* summary 생성 */ }
    
    @EventHandler
    public void on(OrderShipped event) { /* summary 업데이트 */ }
    
    @EventHandler
    public void on(OrderDelivered event) { /* summary 완료 처리 */ }
}
```

**장점:**
- 관련 로직이 한 곳에 응집
- read model의 일관성 보장
- 테스트 용이

### ✅ 비즈니스 자동화별 분리

```java
// 특정 비즈니스 규칙/자동화를 담당하는 리스너
@Component
public class WhenOrderCreatedThenNotifyWarehouse {
    
    @EventListener
    public void handle(OrderCreated event) {
        warehouseNotificationService.notifyNewOrder(event);
    }
}

@Component
public class WhenOrderShippedThenNotifyCustomer {
    
    @EventListener
    public void handle(OrderShipped event) {
        customerNotificationService.sendShippingNotification(event);
    }
}
```

**장점:**
- 클래스명만으로 목적 파악 가능
- Single Responsibility Principle 준수
- 비활성화/테스트가 용이

### 네이밍 패턴 요약

| 목적 | 패턴 | 예시 |
|------|------|------|
| **Read Model 업데이트** | `{Aggregate}Projector` 또는 `{ReadModel}Projection` | `OrderSummaryProjection` |
| **비즈니스 자동화** | `When{Event}Then{Action}` | `WhenOrderCreatedThenNotifyWarehouse` |
| **외부 이벤트 수신 → 도메인 생성** | `{Domain}CreationListener` | `OrderCreationListener` |
| **도메인 이벤트 → 외부 시스템** | `{Domain}{Target}Publisher` | `OrderKafkaPublisher` |
| **범용 (여러 이벤트 처리)** | `{Domain}EventHandler` | `OrderEventHandler` |


## 핸들러 메소드 네이밍

이 부분이 가장 논쟁이 많았다.

### 패턴 비교

| 패턴 | 사용 컨텍스트 | 예시 |
|------|-------------|------|
| **`on(EventType)`** | Axon Framework | `on(OrderCreated event)` |
| **`on{EventName}()`** | 범용 | `onOrderCreated(OrderCreated event)` |
| **`handle(EventType)`** | 단일 이벤트 클래스 | `handle(OrderCreated event)` |
| **비즈니스 동사** | 의도 명시 | `saveTracking(OrderCreated event)` |

### 메소드명에 이벤트명을 포함해야 하나?

```java
// 이벤트명이 2번 등장 — 중복 아닌가?
public void onOrderCreated(OrderCreated event) { }
//             ^^^^^^^^^^^^  ^^^^^^^^^^^^
```

DRY 원칙 위반이라는 지적이 있다.
파라미터 타입이 이미 이벤트를 명시하니까 `on(OrderCreated event)`만으로 충분하다는 것이다.

반면 검색 용이성 관점에서는 이벤트명 포함이 유리하다.

```bash
# 이벤트명 포함: 정확히 찾음
grep -r "onOrderCreated" .
# → 1-2 results

# 오버로딩: 모든 on()이 나옴
grep -r "\.on(" .
# → 500+ results
```

IDE 외의 환경(GitHub, 로그 파일, 터미널)에서 검색할 때 유용하다.

### 권장 결정 매트릭스

결론적으로 **상황에 따라 다르다**.

| 상황 | 권장 패턴 | 예시 |
|------|----------|------|
| 클래스가 **여러 이벤트** 처리 | `on{EventName}()` | `onOrderCreated(event)` |
| 클래스가 **단일 이벤트**만 처리 | `handle(event)` | `handle(event)` |
| 같은 이벤트에 **여러 핸들러** | 비즈니스 동사 | `saveTracking(event)`, `sendNotification(event)` |
| **Axon Framework** 사용 | `on(EventType)` | `on(OrderCreated event)` |

### 구체적 예시

#### 여러 이벤트 처리 → `on{EventName}()`

```java
@Component
public class OrderCreationListener {

    @EventListener
    public void onReceivedOrder(ReceivedOrder event) {
        // 여러 이벤트 처리 → on{EventName} 패턴
    }

    @EventListener
    public void onShippingLabelReceived(ShippingLabelReceived event) {
        // 이벤트명 포함으로 검색 용이
    }
}
```

#### 단일 이벤트 처리 → `handle()`

```java
@Component
public class WhenOrderCreatedThenNotifyWarehouse {

    @EventListener
    public void handle(OrderCreated event) {
        // 클래스명이 목적을 설명 → handle()로 충분
        warehouseService.notify(event);
    }
}
```

#### 같은 이벤트에 여러 핸들러 → 비즈니스 동사

```java
@Component
public class OrderAssignedListener {

    @TransactionalEventListener
    public void saveTracking(OrderAssigned event) {
        // 같은 이벤트, 다른 동작 → 비즈니스 동사로 구분
        trackingRepository.save(Tracking.of(event));
    }

    @TransactionalEventListener
    public void sendNotification(OrderAssigned event) {
        notificationService.send(event);
    }
}
```


## 결론

이벤트 리스너 컨벤션은 무조건 하나의 패턴을 강제하면 안 된다.

**이벤트 네이밍:**
- 과거 시제 사용 (`OrderCreated`, `PaymentCompleted`)
- 비즈니스 관점 네이밍 (기술 관점 ❌)
- Event suffix는 팀 합의 하에 일관되게 (FTGO처럼 혼용도 가능)

**리스너 클래스 분리:**
- 이벤트 타입별 ❌
- Read Model별 ✅
- 비즈니스 자동화별 ✅

**핸들러 메소드 네이밍:**
- 여러 이벤트 처리 → `on{EventName}()`
- 단일 이벤트 처리 → `handle()`
- 같은 이벤트 다중 핸들러 → 비즈니스 동사

다음 글에서는 [Spring @EventListener의 함정들](/posts/spring-event-listener-pitfalls)을 다룬다.


## 참고 자료

| 저자 | 자료 | 핵심 내용 |
|------|------|----------|
| Chris Richardson | [Domain Event Pattern](https://microservices.io/patterns/data/domain-event.html) | 도메인 이벤트는 Aggregate 상태 변경 알림 |
| Chris Richardson | [FTGO Application](https://github.com/microservices-patterns/ftgo-application) | 마이크로서비스 이벤트 구현 예시 |
| Martin Fowler | [Domain Event](https://martinfowler.com/eaaDev/DomainEvent.html) | 불변 소스 데이터 + 가변 처리 데이터 |
| Vaughn Vernon | [IDDD_Samples](https://github.com/VaughnVernon/IDDD_Samples) | 도메인 이벤트 구현 예시 |
| Mathias Verraes | [Messaging Patterns](https://verraes.net/2019/06/messaging-patterns-natural-language/) | 비즈니스 관점 네이밍 |
| Axon Framework | [Event Handling](https://docs.axoniq.io/reference-guide/axon-framework/events/event-handlers) | 핸들러 분리 기준 |
