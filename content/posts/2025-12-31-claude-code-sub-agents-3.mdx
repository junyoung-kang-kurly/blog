---
title: "Claude Code 서브에이전트 (3) - 오케스트레이터 패턴"
description: "PM-엔지니어-QA 세 에이전트가 협업하는 오케스트레이터 워크플로우 실습."
date: "2025-12-31"
published: true
tags: ["claude-code", "agents", "orchestrator", "workflow"]
series: "claude-code-sub-agents"
seriesOrder: 3
---

## 오케스트레이터 패턴이란

여러 에이전트가 서로 소통하며 점진적으로 결과물을 만들어가는 패턴이다.
실제 팀 협업 구조와 비슷해서 직관적이다.

```
PM (기획) ←──────────────────┐
    ↓                        │
엔지니어 (개발) ──→ 피드백 ──┘
    ↓
QA (검증) ──→ 통과/재개발 요청
```

![](/images/posts/claude-code-sub-agents-3-orchestrator-loop.svg)

이번 실습에서는 PM, 엔지니어, QA 세 역할이 협업하는 시나리오를 구현했다.

## 역할 설계

### PM (오케스트레이터)
- 데이터를 보고 인사이트 기획
- 엔지니어, QA와 소통하며 기획 개선
- 최종 요구사항 정리

### 프로덕트 엔지니어
- 기획 내용을 파악하고 코드 개발
- 데이터 시각화 구현
- 실무 관점에서 PM에게 피드백

### QA
- 개발 내용의 의도를 이해하고 검증
- 체크리스트 기반 테스트
- 통과 여부 판단

## 실행 프롬프트

```
3개의 서브에이전트를 만들어 서로 소통하며 최선의 결과물을 만드세요.
Claude Code의 Task tool로 3개 서브에이전트 실행하면 됩니다.
MCP나 도구는 사용하지 말고 현재경로의 엑셀파일을 통해서만 분석 및 결과물을 도출하세요.
각 Task tool 간에 소통하는 과정을 사용자에게 설명하면서 진행하세요.

1. PM (오케스트레이터)
1-1. 데이터를 보고 어떤 인사이트를 제공하면 좋을지 기획
1-2. 엔지니어, QA와 소통하며 기획을 점진적으로 개선

2. 프로덕트 엔지니어
2-1. 기획 내용을 파악하고, 집계 코드 및 데이터 시각화 개발
2-2. 더 좋은 의견이 있으면 실무자 관점에서 PM과 소통

3. QA
3-1. PM과 엔지니어가 개발한 내용의 의도를 이해하고 문제 확인
3-2. 체크리스트를 만들어 통과 여부 판단

각 Task가 완료되면 사용자에게 최종 보고하세요.
```

핵심 포인트:
- **"소통하는 과정을 설명하면서"**: 에이전트 간 대화를 사용자에게 보여줌
- **역할별 책임 명시**: 각 에이전트가 무엇을 해야 하는지 구체적으로 기술
- **파일 기반 소통**: JSON 파일로 요구사항, 피드백, 리포트를 주고받음

## 실행 결과

### PM 에이전트

30일간의 배송 데이터를 분석하고 5가지 핵심 인사이트를 도출했다:

| 우선순위 | 인사이트 | 핵심 수치 |
|----------|----------|-----------|
| HIGH | 배송량-지연율 상관관계 | 상관계수 0.55, 17,000건 초과 시 위험 |
| HIGH | 화요일 성과 급락 | 지연율 0.93% (평균의 2배) |
| HIGH | 8월 7일 실패율 폭증 | 1.49% (평균의 5배) |
| MEDIUM | 주차별 성과 개선 트렌드 | 7월 0.42% → 8월 0.35% |
| MEDIUM | 변경율 개선 기회 | 0.76% (고객 경험 개선) |

엔지니어에게 전달한 요구사항:
- 5종 시각화 구현 (산점도, 막대그래프, 시계열, 그룹 막대그래프, 히트맵)
- 통계 분석 (상관계수, 이상치 탐지)

산출물: `pm_requirements.json`

### 엔지니어 에이전트

PM 요구사항을 검토하고 개발을 수행했다:

- PM의 5가지 인사이트 모두 데이터로 검증
- 요청한 5종 시각화 + 종합 대시보드 추가 개발
- 747줄 분석 스크립트 작성

PM에게 9가지 피드백을 전달했다:

**높은 우선순위 (즉시 조치)**
1. 알림 임계값 재설정 (평균 + 1.5σ 권장)
2. deliveryCenters 컬럼 구조 확인 필요
3. 실패 사유 코드 추가 수집

**중간 우선순위 (1~2주 내)**
4. 데이터 버전 관리 프로세스
5. 다변량 예측 모델 설계

**낮은 우선순위 (Phase 2)**
6. 인터랙티브 대시보드 (현재 정적 시각화로 충분)
7. RESTful API (외부 연동 시점에 개발)

산출물: `engineer_feedback.json`, `analyze_delivery.py`, 시각화 6종

### QA 에이전트

PM과 엔지니어 문서를 완벽히 이해하고 검증을 수행했다:

| 항목 | 결과 | 상세 |
|------|------|------|
| 스크립트 실행 | Pass | 8.2초, 에러 없음 |
| 시각화 생성 | Pass | 6개 파일 정상 생성 |
| 데이터 정확성 | Pass | 소수점 6자리까지 100% 일치 |
| PM 요구사항 충족 | Pass | 5가지 인사이트 모두 검증 |
| 코드 품질 | Pass | 747줄, 95줄 주석 |

발견된 이슈:
- Blocker: 0건
- Critical: 0건
- Major: 2건 (에러 처리, 경로 하드코딩)
- Minor: 5건 (폰트, 로깅, 테스트 등)

최종 판정: **Pass** (프로덕션 배포 가능)
품질 점수: **9.2/10**

산출물: `qa_report.json`

## 에이전트 간 소통 흐름

```
PM (기획)
  ↓ pm_requirements.json
  ↓ "5가지 인사이트 + 대시보드 개발 요청"
  ↓
엔지니어 (개발)
  ↓ analyze_delivery.py + 시각화 6종
  ↑ engineer_feedback.json
  ↑ "기대치 초과 달성 + 9가지 피드백"
  ↑
PM ← (피드백 루프 - 개선 제안)
  ↓
QA (검증)
  ↓ qa_report.json
  ↓ "Pass 판정 + 2건 Major 이슈"
  ↓
배포 승인 ✅
```

## 최종 산출물

```
agents-study/
├── pm_requirements.json      # PM 기획 문서
├── engineer_feedback.json    # 엔지니어 피드백
├── qa_report.json            # QA 검증 리포트
├── analyze_delivery.py       # 메인 분석 스크립트 (747줄)
├── README.md                 # 실행 가이드
└── visualizations/           # 시각화 결과
    ├── 1_volume_delay_scatter.png
    ├── 2_dayofweek_performance.png
    ├── 3_failure_timeseries.png
    ├── 4_weekly_trend.png
    ├── 5_correlation_heatmap.png
    └── 6_comprehensive_dashboard.png
```

## 실습하면서 느낀 점

### 잘 된 점

- 역할 분리가 명확하면 결과물 품질이 올라간다
- PM-엔지니어-QA 패턴은 실제 협업 구조와 비슷해서 직관적이다
- 파일 기반 소통이 에이전트 간 컨텍스트 전달에 효과적이다
- 엔지니어가 PM 요구사항을 초과 달성하는 경우도 있다

### 주의할 점

- 프롬프트가 애매하면 시뮬레이션 코드를 작성하는 등 의도와 다르게 동작할 수 있다
- "소통하는 과정을 설명하면서 진행하세요" 같은 명시적 요구사항이 중요하다
- 에이전트가 많아지면 총 실행 시간이 길어진다 (이 실습은 약 2~3시간 소요)

### 확장 아이디어

- **평가자 루프 추가**: QA 결과가 실패하면 엔지니어에게 재개발 요청
- **더 많은 역할**: 디자이너, 데이터 엔지니어 등 추가
- **비동기 소통**: 일부 에이전트는 병렬로 실행

## 정리

PM-엔지니어-QA 세 에이전트가 협업하는 오케스트레이터 패턴을 실습했다.
각 에이전트가 자신의 역할에 집중하고, 파일로 소통하며, 점진적으로 결과물을 개선했다.

실무에서 반복적인 분석 작업이나 리뷰 프로세스에 적용해 볼 만한 가치가 있어 보인다.
역할 설계와 프롬프트 품질이 결과물에 큰 영향을 미친다는 것도 확인했다.
