---
title: "DDD 이벤트 설계 안티패턴"
description: "이벤트 비대화, Command vs Event 혼동 등 DDD 이벤트 설계에서 자주 발생하는 안티패턴들을 정리했다. Event Sourcing 맥락과 일반 Spring 애플리케이션 맥락의 차이도 다룬다."
date: "2026-02-01"
published: true
tags: ["java", "spring", "event-driven", "ddd", "architecture"]
---

## 들어가며

DDD 이벤트 설계에 대한 조언들이 많지만, 대부분 **Event Sourcing 컨텍스트**에서 나온 것들이다.
일반적인 Spring 애플리케이션에 그대로 적용하면 오히려 문제가 될 수 있다.

이 글에서는 각 안티패턴을 소개하고, **비판적 시각**으로 언제 적용하고 언제 적용하지 말아야 하는지 다룬다.

> **시리즈 안내**
> - [Part 1: 이벤트 네이밍과 리스너 컨벤션](/posts/spring-event-listener-conventions)
> - [Part 2: Spring @EventListener 함정과 해결책](/posts/spring-event-listener-pitfalls)
> - Part 3: DDD 이벤트 설계 안티패턴 (현재 글)


## 이벤트 비대화

### 안티패턴: "편의를 위한" 필드 추가

> "I'll just add one more field"
>
> — [Oskar Dudycz](https://event-driven.io/en/i_will_just_add_one_more_field/)

"편의를 위해" 필드를 계속 추가하면 이벤트의 비즈니스 의미가 상실된다.

```java
// ❌ 비권장: 편의를 위한 중복 필드 추가
public record IncidentResolved(
    UUID incidentId,
    UUID customerId,        // "편의를 위해" 추가
    UUID assignedAgentId,   // "리포팅을 위해" 추가
    String customerEmail,   // "알림을 위해" 추가
    ResolutionType resolution,
    UUID resolvedBy,
    Instant resolvedAt
) {}
```

**위험성:**
- 모호함: `customerId`가 있으면 인시던트를 다른 고객에게 이전할 수 있다는 뜻?
- 필드마다 인지 부하 증가
- 미래 개발자가 의도를 의심

**권장 해결책:**

```java
// ✅ 권장: 최소한의 필수 정보만
public record IncidentResolved(
    UUID incidentId,
    ResolutionType resolution,
    UUID resolvedBy,
    Instant resolvedAt
) {}

// customerId가 필요하면 IncidentLogged 이벤트를 조회
```

### ⚠️ 비판적 시각: Event Sourcing 전제 조건

위 해결책은 **Event Sourcing 컨텍스트**에서 나온 조언이다.
Event Store가 있어서 과거 이벤트(`IncidentLogged`)를 조회할 수 있다는 전제가 깔려있다.

**일반적인 Spring 애플리케이션에서는:**
- Event Sourcing을 쓰지 않는 경우가 많음
- 이벤트는 발행 후 사라짐 (in-memory `ApplicationEvent`)
- 과거 이벤트를 "조회"하는 게 불가능

```java
// Event Sourcing 없는 환경에서 "최소한의 이벤트" 사용 시
@TransactionalEventListener
public void sendNotification(IncidentResolved event) {
    // customerId가 없어서 매번 DB 조회 필요
    Incident incident = incidentRepository.findById(event.incidentId());
    Customer customer = customerRepository.findById(incident.getCustomerId());
    notificationService.send(customer.getEmail(), ...);
    // 조회 비용 증가 + Repository 의존성 증가
}
```

### 실용적 가이드라인

| 상황 | 권장 접근 |
|------|----------|
| Event Sourcing 사용 | 최소한의 ID만 포함, 과거 이벤트에서 조회 |
| 일반 Spring 앱 + 단일 리스너 | 필요한 필드 포함해도 무방 |
| 일반 Spring 앱 + 다중 리스너 | 공통으로 필요한 필드만 포함, 각 리스너에서 추가 조회 |

핵심은 **"편의"가 아닌 "필요"**로 필드를 결정하는 것이다.

- ❌ "혹시 나중에 필요할 것 같아서" → 추가하지 말 것
- ✅ "모든 리스너가 반드시 필요로 함" → 포함해도 됨


## Command를 Event로 위장

### 안티패턴: 단일 수신 의도를 pub-sub으로 발행

단일 컨슈머가 처리해야 할 Command를 이벤트로 발행하면 문제가 생긴다.

```java
// ❌ 위험: 이것은 COMMAND지 Event가 아님!
eventPublisher.publish(new ProcessPaymentEvent(orderId, amount));

// 여러 리스너가 구독
@EventListener
public void processPayment1(ProcessPaymentEvent event) { /* 결제 처리 */ }

@EventListener  
public void processPayment2(ProcessPaymentEvent event) { /* 또 결제 처리! */ }
// 결제가 2번 처리됨!
```

**권장 해결책:**

```java
// Command는 단일 수신자
commandBus.send(new ProcessPaymentCommand(orderId, amount));

// Event는 발생한 사실 알림
eventPublisher.publish(new PaymentProcessed(orderId, amount));
```

### ⚠️ 비판적 시각: 네이밍이 문제지 패턴이 문제는 아니다

위 예시에서 진짜 문제는:

1. **네이밍**: `ProcessPaymentEvent`가 명령형(동사 원형)이라 Command처럼 보임
2. **중복 리스너**: 같은 동작을 하는 리스너가 여러 개 등록됨

**Saga/Choreography 패턴에서는 이벤트가 다음 액션을 트리거하는 게 정상이다:**

```java
// 이건 올바른 Choreography 패턴
eventPublisher.publish(new PaymentRequested(orderId, amount));

// PaymentService가 듣고 처리
@EventListener
public void handle(PaymentRequested event) {
    paymentGateway.process(event);
    eventPublisher.publish(new PaymentCompleted(event.orderId()));
}

// InventoryService도 들을 수 있음 (다른 목적)
@EventListener
public void handle(PaymentRequested event) {
    inventoryService.reserveStock(event.orderId());
}
```

### Command vs Event 구분

| 특성 | Command | Event |
|------|---------|-------|
| 시제 | 명령형 (`ProcessPayment`) | 과거형 (`PaymentProcessed`) |
| 수신자 | 단일 | 다중 가능 |
| 실패 시 | 재시도 | 보상 트랜잭션 |
| 응답 | 필요 | 불필요 |
| 의도 | "이것을 해라" | "이것이 일어났다" |


## Event Sourcing 남용

### 안티패턴: 전체 시스템에 Event Sourcing 적용

> "CQRS and Event Sourcing are not a top level architecture and should be used within the confines of specific bounded contexts."
>
> — [Greg Young](https://www.infoq.com/news/2016/04/event-sourcing-anti-pattern/)

Event Sourcing을 전체 시스템에 적용하는 건 안티패턴이다.

**문제점:**
- 이벤트 스키마 버전 관리의 복잡성
- 마이그레이션 어려움
- 모든 팀이 Event Sourcing을 이해해야 함
- CRUD가 더 적합한 도메인도 있음

### 언제 Event Sourcing을 쓸까?

| 적합한 경우 | 부적합한 경우 |
|------------|-------------|
| 감사 로그가 법적 요구사항 | 단순 CRUD |
| 시간 여행(과거 상태 조회) 필요 | 현재 상태만 중요 |
| 복잡한 비즈니스 규칙 | 단순한 데이터 관리 |
| 이벤트 기반 통합 필수 | 단일 서비스 |


## 이벤트 스키마 결합

### 안티패턴: 이벤트에 엔티티 전체 포함

```java
// ❌ 비권장: 엔티티 전체를 이벤트에 포함
public record OrderCreated(
    Order order  // 엔티티 전체
) {}
```

**문제점:**
- `Order` 엔티티 변경 시 이벤트 스키마도 변경
- 불필요한 정보 노출
- 직렬화/역직렬화 복잡성

### 권장 해결책

```java
// ✅ 권장: 필요한 값만 추출
public record OrderCreated(
    UUID orderId,
    UUID customerId,
    Money totalAmount,
    Instant createdAt
) {}
```

또는 전용 DTO 사용:

```java
public record OrderCreated(
    OrderCreatedPayload payload
) {}

public record OrderCreatedPayload(
    UUID orderId,
    UUID customerId,
    Money totalAmount
) {}
```


## 이벤트 버전 관리 무시

### 안티패턴: 스키마 변경 시 하위 호환성 무시

이벤트 스키마를 변경할 때 기존 이벤트를 처리 못하게 되는 경우가 있다.

```java
// V1
public record OrderCreated(UUID orderId, Money amount) {}

// V2 - 필드 추가 (하위 호환 ✅)
public record OrderCreated(UUID orderId, Money amount, String currency) {}

// V2 - 필드 제거 (하위 호환 ❌)
public record OrderCreated(UUID orderId) {}  // amount 없음!

// V2 - 타입 변경 (하위 호환 ❌)
public record OrderCreated(UUID orderId, BigDecimal amount) {}  // Money → BigDecimal
```

### 권장 해결책

**1. 필드 추가는 OK, 제거/변경은 새 이벤트 타입으로:**

```java
// 기존 이벤트 유지
public record OrderCreated(UUID orderId, Money amount) {}

// 새 버전은 새 타입으로
public record OrderCreatedV2(UUID orderId, Money amount, String currency) {}
```

**2. 업캐스터 패턴 (Axon Framework 등):**

```java
public class OrderCreatedUpcaster implements Upcaster {
    @Override
    public Stream<IntermediateEventRepresentation> upcast(
            Stream<IntermediateEventRepresentation> events) {
        return events.map(event -> {
            if (event.getType().equals("OrderCreated")) {
                // V1 → V2 변환
                return event.upcast("OrderCreatedV2", 
                    data -> data.put("currency", "USD"));
            }
            return event;
        });
    }
}
```


## 결론: 이벤트 설계 체크리스트

### 이벤트 구조

- [ ] 과거 시제 네이밍 (`OrderCreated`, not `CreateOrder`)
- [ ] 비즈니스 관점 (`CustomerRegistered`, not `UserTableInserted`)
- [ ] 불변 객체 (record 또는 final fields)
- [ ] 필요한 필드만 포함 (but "필요"의 기준은 컨텍스트에 따라 다름)

### 이벤트 발행

- [ ] Command와 Event 구분 명확
- [ ] 단일 수신 의도면 Command 패턴 사용
- [ ] 다중 리스너가 같은 동작을 하지 않는지 확인

### 스키마 관리

- [ ] 하위 호환성 고려
- [ ] 필드 제거/타입 변경 시 새 이벤트 타입
- [ ] 버전 관리 전략 수립 (Event Sourcing 사용 시)

### 컨텍스트 인식

- [ ] Event Sourcing vs 일반 Spring 앱 구분
- [ ] 전체 시스템이 아닌 특정 Bounded Context에만 Event Sourcing
- [ ] CRUD가 더 적합한 도메인은 CRUD 사용


## 참고 자료

| 저자 | 자료 | 핵심 내용 |
|------|------|----------|
| Oskar Dudycz | [I'll just add one more field](https://event-driven.io/en/i_will_just_add_one_more_field/) | 이벤트 비대화 경고 |
| Greg Young | [Event Sourcing Anti-pattern](https://www.infoq.com/news/2016/04/event-sourcing-anti-pattern/) | 전체 시스템 ES는 안티패턴 |
| Martin Fowler | [Domain Event](https://martinfowler.com/eaaDev/DomainEvent.html) | 불변 소스 데이터 원칙 |
| Chris Richardson | [Domain Event Pattern](https://microservices.io/patterns/data/domain-event.html) | Aggregate 상태 변경 알림 |
| Vaughn Vernon | [Effective Aggregate Design](https://www.dddcommunity.org/library/vernon_2011/) | Aggregate와 이벤트 설계 |
