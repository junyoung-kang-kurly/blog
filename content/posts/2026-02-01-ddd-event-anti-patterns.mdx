---
title: "DDD 이벤트 설계 안티패턴"
description: "이벤트 비대화, Command vs Event 혼동 등 DDD 이벤트 설계에서 자주 발생하는 안티패턴들을 정리했다. Event Sourcing 조언을 일반 Spring 앱에 맹목적으로 적용할 때 생기는 문제도 다룬다."
date: "2026-02-01"
published: true
tags: ["java", "spring", "event-driven", "ddd", "architecture"]
---

## 들어가며

DDD 이벤트 설계에 대한 조언들이 많다.
문제는 대부분 **Event Sourcing 컨텍스트**에서 나온 것들이라는 점이다.

일반적인 Spring 애플리케이션에 그대로 적용하면 오히려 불필요한 복잡성만 늘어난다.
이 글에서는 각 안티패턴을 소개하고, **일반 Spring 앱 관점**에서 어떻게 적용해야 하는지 다룬다.

> **시리즈 안내**
> - [Part 1: 이벤트 네이밍과 리스너 컨벤션](/posts/spring-event-listener-conventions) - 네이밍 규칙, 리스너 배치
> - [Part 2: Spring @EventListener 함정과 해결책](/posts/spring-event-listener-pitfalls) - 트랜잭션 타이밍, 예외 처리
> - Part 3: DDD 이벤트 설계 안티패턴 (현재 글) - 구조적 설계 실수


## 이벤트 비대화

### 안티패턴: "편의를 위한" 필드 추가

> "I'll just add one more field"
>
> — [Oskar Dudycz](https://event-driven.io/en/i_will_just_add_one_more_field/)

"편의를 위해" 필드를 계속 추가하면 이벤트의 비즈니스 의미가 흐려진다.

```java
// ❌ 비권장: 편의를 위한 중복 필드 추가
public record IncidentResolved(
    UUID incidentId,
    UUID customerId,        // "편의를 위해" 추가
    UUID assignedAgentId,   // "리포팅을 위해" 추가
    String customerEmail,   // "알림을 위해" 추가
    ResolutionType resolution,
    UUID resolvedBy,
    Instant resolvedAt
) {}
```

**위험성:**
- 모호함: `customerId`가 있으면 인시던트를 다른 고객에게 이전할 수 있다는 뜻?
- 필드마다 인지 부하 증가
- 미래 개발자가 의도를 의심

원칙론자들은 이렇게 권장한다:

```java
// Event Sourcing 권장안: 최소한의 필수 정보만
public record IncidentResolved(
    UUID incidentId,
    ResolutionType resolution,
    UUID resolvedBy,
    Instant resolvedAt
) {}

// customerId가 필요하면 IncidentLogged 이벤트를 조회
```

### 일반 Spring 앱에서는?

위 해결책은 **Event Sourcing 컨텍스트**에서 나온 조언이다.
Event Store가 있어서 과거 이벤트(`IncidentLogged`)를 조회할 수 있다는 전제가 깔려있다.

**일반적인 Spring 애플리케이션에서는:**
- Event Sourcing을 쓰지 않는 경우가 많음
- 이벤트는 발행 후 사라짐 (in-memory `ApplicationEvent`)
- 과거 이벤트를 "조회"하는 게 불가능

```java
// Event Sourcing 없는 환경에서 "최소한의 이벤트" 사용 시
@TransactionalEventListener
public void sendNotification(IncidentResolved event) {
    // customerId가 없어서 매번 DB 조회 필요
    Incident incident = incidentRepository.findById(event.incidentId());
    Customer customer = customerRepository.findById(incident.getCustomerId());
    notificationService.send(customer.getEmail(), ...);
    // 조회 비용 증가 + Repository 의존성 증가
}
```

### 실용적 가이드라인

| 상황 | 권장 접근 |
|------|----------|
| Event Sourcing 사용 | 최소한의 ID만 포함, 과거 이벤트에서 조회 |
| 일반 Spring 앱 + 단일 리스너 | 필요한 필드 포함해도 무방 |
| 일반 Spring 앱 + 다중 리스너 | 공통으로 필요한 필드만 포함, 각 리스너에서 추가 조회 |

핵심은 **"편의"가 아닌 "필요"**로 필드를 결정하는 것이다.

- ❌ "혹시 나중에 필요할 것 같아서" → 추가하지 말 것
- ✅ "모든 리스너가 반드시 필요로 함" → 포함해도 됨


## Command를 Event로 위장

### 안티패턴: 명령을 이벤트처럼 발행

단일 컨슈머가 처리해야 할 Command를 이벤트로 발행하면 문제가 생긴다.

```java
// ❌ 위험: 이것은 Command지 Event가 아님!
eventPublisher.publish(new ProcessPaymentEvent(orderId, amount));

// 여러 리스너가 구독하면?
@EventListener
public void processPayment1(ProcessPaymentEvent event) { /* 결제 처리 */ }

@EventListener
public void processPayment2(ProcessPaymentEvent event) { /* 또 결제 처리! */ }
// 결제가 2번 처리됨!
```

### 진짜 문제는 네이밍

위 예시에서 근본적인 문제는 두 가지다:

1. **네이밍**: `ProcessPaymentEvent`가 명령형(동사 원형)이라 Command처럼 보임
2. **중복 리스너**: 같은 동작을 하는 리스너가 여러 개 등록됨

이벤트 이름이 과거/완료형이면 여러 리스너가 "각자 다른 목적으로" 반응하는 게 자연스럽다.

```java
// ✅ 권장: 과거형 네이밍
eventPublisher.publish(new PaymentCompleted(orderId, amount));

// 각 리스너가 다른 목적으로 반응
@EventListener
public void sendReceipt(PaymentCompleted event) { /* 영수증 발송 */ }

@EventListener
public void updateInventory(PaymentCompleted event) { /* 재고 차감 */ }
// 각자 다른 일을 하므로 문제없음
```

### Command vs Event 구분

| 특성 | Command | Event |
|------|---------|-------|
| 시제 | 명령형 (`ProcessPayment`) | 과거형 (`PaymentProcessed`) |
| 수신자 | 단일 | 다중 가능 |
| 실패 시 | 재시도 | 보상 트랜잭션 |
| 응답 | 필요 | 불필요 |
| 의도 | "이것을 해라" | "이것이 일어났다" |

Part 1에서 다룬 [네이밍 컨벤션](/posts/spring-event-listener-conventions#이벤트-네이밍)을 따르면 이 문제는 자연스럽게 해결된다.


## 이벤트에 엔티티 통째로 넣기

### 안티패턴: 엔티티 전체를 이벤트에 포함

```java
// ❌ 비권장: 엔티티 전체를 이벤트에 포함
public record OrderCreated(
    Order order  // 엔티티 전체
) {}
```

**문제점:**
- `Order` 엔티티 변경 시 이벤트 스키마도 변경
- 불필요한 정보 노출 (내부 상태, 연관 엔티티)
- 직렬화/역직렬화 복잡성 (JPA 프록시, 순환 참조)

### 권장 해결책

```java
// ✅ 권장: 필요한 값만 추출
public record OrderCreated(
    UUID orderId,
    UUID customerId,
    Money totalAmount,
    Instant createdAt
) {}
```

이벤트 발행 시점에 필요한 값을 명시적으로 추출한다:

```java
public void createOrder(CreateOrderCommand cmd) {
    Order order = Order.create(cmd);
    orderRepository.save(order);

    // 엔티티가 아닌 값을 전달
    eventPublisher.publish(new OrderCreated(
        order.getId(),
        order.getCustomerId(),
        order.getTotalAmount(),
        order.getCreatedAt()
    ));
}
```


## 이벤트 버전 관리 무시

### 안티패턴: 하위 호환성 깨는 스키마 변경

이벤트를 외부 시스템과 공유하거나, 메시지 큐에 저장하는 경우 스키마 변경이 문제가 된다.

```java
// V1
public record OrderCreated(UUID orderId, Money amount) {}

// V2 - 필드 추가 (하위 호환 ✅)
public record OrderCreated(UUID orderId, Money amount, String currency) {}

// V2 - 필드 제거 (하위 호환 ❌)
public record OrderCreated(UUID orderId) {}  // amount 없음!

// V2 - 타입 변경 (하위 호환 ❌)
public record OrderCreated(UUID orderId, BigDecimal amount) {}  // Money → BigDecimal
```

### 일반 Spring 앱에서는?

**in-memory `ApplicationEvent`만 쓴다면** 버전 관리가 크게 중요하지 않다.
이벤트가 메모리에서 바로 소비되므로 스키마 불일치가 발생할 일이 없다.

**버전 관리가 중요한 경우:**
- Kafka, RabbitMQ 등 메시지 브로커 사용
- 이벤트를 DB에 저장 (Outbox 패턴)
- 외부 시스템과 이벤트 공유

### 권장 해결책

**필드 추가는 OK, 제거/변경은 새 이벤트 타입으로:**

```java
// 기존 이벤트 유지
public record OrderCreated(UUID orderId, Money amount) {}

// 새 버전은 새 타입으로
public record OrderCreatedV2(UUID orderId, Money amount, String currency) {}
```

Event Sourcing을 쓴다면 Axon Framework의 Upcaster 같은 도구를 검토할 수 있다.
하지만 일반 Spring 앱에서는 대부분 새 이벤트 타입으로 충분하다.


## Event Sourcing 남용

### 안티패턴: 전체 시스템에 Event Sourcing 적용

> "CQRS and Event Sourcing are not a top level architecture and should be used within the confines of specific bounded contexts."
>
> — [Greg Young](https://www.infoq.com/news/2016/04/event-sourcing-anti-pattern/)

Event Sourcing의 창시자인 Greg Young조차 전체 시스템 적용을 경고한다.

**Event Sourcing이 가져오는 복잡성:**
- 모든 상태 변경을 이벤트로 모델링해야 함
- 이벤트 스키마 버전 관리 필수
- 현재 상태 조회를 위해 이벤트 리플레이 또는 별도 프로젝션 필요
- 팀 전체가 Event Sourcing을 이해해야 함

### CRUD가 더 나은 경우

솔직히 대부분의 도메인은 CRUD로 충분하다.

| Event Sourcing이 적합한 경우 | CRUD가 더 나은 경우 |
|----------------------------|-------------------|
| 감사 로그가 법적 요구사항 | 현재 상태만 중요 |
| 과거 시점 상태 조회 필요 | 단순한 데이터 관리 |
| 복잡한 비즈니스 규칙 + 디버깅 필요 | 표준적인 CRUD 작업 |
| 이벤트 기반 외부 통합 필수 | 단일 서비스 내부 |

**예시:**
- 주문 시스템의 결제 도메인 → Event Sourcing 고려 가능 (감사, 추적 중요)
- 사용자 프로필 관리 → CRUD로 충분
- 상품 카탈로그 → CRUD로 충분
- 재고 이력 추적 → Event Sourcing 고려 가능


## 결론: 이벤트 설계 체크리스트

### 이벤트 구조

- [ ] 과거 시제 네이밍 (`OrderCreated`, not `CreateOrder`)
- [ ] 비즈니스 관점 (`CustomerRegistered`, not `UserTableInserted`)
- [ ] 불변 객체 (record 사용)
- [ ] 엔티티가 아닌 값 타입으로 구성

### 필드 결정

- [ ] "편의"가 아닌 "필요"로 필드 결정
- [ ] Event Sourcing 없으면 리스너가 필요로 하는 필드 포함 가능
- [ ] 엔티티 전체가 아닌 필요한 값만 추출

### Command vs Event

- [ ] 명령형 네이밍이면 Command로 분리
- [ ] 다중 리스너가 같은 동작을 하지 않는지 확인

### 버전 관리 (메시지 브로커 사용 시)

- [ ] 필드 추가만 허용
- [ ] 필드 제거/타입 변경 시 새 이벤트 타입

### 아키텍처

- [ ] Event Sourcing은 특정 Bounded Context에만 적용
- [ ] CRUD가 더 적합하면 CRUD 사용


## 참고 자료

| 저자 | 자료 | 핵심 내용 |
|------|------|----------|
| Oskar Dudycz | [I'll just add one more field](https://event-driven.io/en/i_will_just_add_one_more_field/) | 이벤트 비대화 경고 |
| Greg Young | [Event Sourcing Anti-pattern](https://www.infoq.com/news/2016/04/event-sourcing-anti-pattern/) | 전체 시스템 ES는 안티패턴 |
| Martin Fowler | [Domain Event](https://martinfowler.com/eaaDev/DomainEvent.html) | 도메인 이벤트 정의 |
| Chris Richardson | [Domain Event Pattern](https://microservices.io/patterns/data/domain-event.html) | Aggregate 상태 변경 알림 |
